#--------------------------------------------------------------------------------------#

# function to print board
# using a nested loop, we iterate through the list of lists to determine what to print at a particular spot
# for this game, Player 1 is always 'X' and Player 2 is always 'O'

def print_board(game):
    for x in range(0,3): # row
        for y in range (0,3): # column
            if (game[x][y]==0): # available spot
                print(" ", end="")
            elif (game[x][y]==1): # taken by Player 1[X]
                print("X", end="")
            elif (game[x][y]==2): # taken by Player 2[O]
                print("O", end="")
   
            if y<2:
                print(" | ", end="")
            else:
                print()
        if x<2:
            print("---------")


# function to determine if it's a draw, a player won and declare the winner, or continue playing

def game_stat(winCondition,game):
    win=False
    player=0
    # we check the three arrays inside game to see if all possible moves have been used
    if (0 not in game[0]) and (0 not in game[1]) and (0 not in game[2]):
        return 3 # it's a draw!
    else:
        for i in range(0,3): # checks if each entry matches and is not 0.
            if (game[i][0] == game[i][1] == game[i][2]):   # check columns
                win=True
                player=game[i][0]
            elif (game[0][i] == game[1][i] == game[2][i]): # check rows
                win=True
                player=game[0][i]
            elif (game[0][0] == game[1][1] == game[2][2]): # check diagonal topL2botR
                win=True
                player=game[0][0] 
            elif (game[0][2]== game[1][1] == game[2][0]):  # check diagonal topR2botL
                win=True
                player=game[0][2]

            if win==True and player != 0:
                return player # winCondition 1 or 2
            else:
                return 0 # it's not over yet
                          			       

            
# function to update board
# validates an open spot, then returns an updated board OR
# it returns the existing board, which will be registered as an invalid move (seats taken)

def add_piece(game,row,col,player):

    copyBoard=[[0,0,0],[0,0,0],[0,0,0]]
    for x in range(0,3):
            for y in range(0,3):
                copyBoard[x][y] = game[x][y]
    if (row>=0 and col>=0 and row<=3 and col <=3): 
        if (copyBoard[row][col] == 0):
                copyBoard[row][col] = player
                return copyBoard
    return copyBoard



#------------------------------------------------------------------------------------#

# main game

def ticTacToe():
    game=[[0,0,0],[0,0,0],[0,0,0]]
    winCondition=0
    turn=0
        
    while winCondition==0:
        #setting up variables for the player using the incremented variable turn
        player = turn%2+1
        if player==1:
            symbol="X"
        else:
            symbol="O"
            
        print_board(game)
        print()
        validMove = False
                
        print(f"Turn: {turn}".format(turn))
        while validMove == False: # until the players move is determined valid, this will remain false.
            while True:
                print("Using the board above as a guide, select the grid for your next move.")
                print(f"Player {player} ['{symbol}'], you're up.".format(player,symbol))
                move = input(f'Enter the row and column | Ex) 1st Row, 3rd Col = 1,3: ').split(",")
                
                try: # test user input
                    val = int(move[0]) and int(move[1]) # is an integer
                    break
                except:
                    print() # just a spacer
                    print("Invalid user entry provided, not an integer!")
                    print()

            newboard = add_piece(game,int(move[0])-1, int(move[1])-1,player)
            # we have to reduce their value by one in order to use the correct index [starts at zero]
            if (bool(game == newboard)==False):
                validMove=True
                game=add_piece(game,int(move[0])-1, int(move[1])-1,player)
            else:
                print() # just a spacer
                print("Invalid move. Please try again!")
                print()
                print_board(game)
                print()


        print() 
	#increment the turn, and determine if it's a win/draw	
        turn=turn+1
        if turn>=4:
            winCondition=game_stat(winCondition,game)

    #outside the while loop, because the game has ended
    if winCondition==1 or winCondition==2:
        print(f"Player {winCondition} wins!".format(winCondition))
        print()
    else:
        print("Draw!") # winCondition==3 and all moves made
        print()
    print_board(game)
        

# we call the main game function after a welcome message

print("Welcome to Tic Tac Toe!")
print("Player one will play as 'X' and will go first.")
print()
ticTacToe()
            
